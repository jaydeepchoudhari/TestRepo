DECLARE @sql NVARCHAR(MAX) = 'Your very long dynamic SQL query...'
DECLARE @i INT = 1
DECLARE @chunk_size INT = 4000

WHILE @i <= LEN(@sql)
BEGIN
    PRINT SUBSTRING(@sql, @i, @chunk_size)
    SET @i = @i + @chunk_size
END


CREATE FUNCTION dbo.QuotenameLong(@input NVARCHAR(MAX), @quote_char NCHAR(1) = '[')
RETURNS NVARCHAR(MAX)
AS
BEGIN
    DECLARE @chunk_size INT = 128
    DECLARE @result NVARCHAR(MAX) = ''
    DECLARE @i INT = 1
    DECLARE @len INT = LEN(@input)
    
    WHILE @i <= @len
    BEGIN
        DECLARE @chunk NVARCHAR(128) = SUBSTRING(@input, @i, @chunk_size)
        SET @result = @result + QUOTENAME(@chunk, @quote_char)
        SET @i = @i + @chunk_size
    END
    
    RETURN @result
END
GO




# PowerShell script to remove $break$ and join broken lines (removes 2 newlines)
param(
    [Parameter(Mandatory=$true)]
    [string]$FilePath
)

# Check if file exists
if (-not (Test-Path $FilePath)) {
    Write-Error "File not found: $FilePath"
    exit 1
}

try {
    # Read the entire file content
    $content = Get-Content -Path $FilePath -Raw
    
    # Pattern to find $break$ and remove it along with 2 newlines
    # This matches: text, newline, $break$, newline, text
    $pattern = '([^\r\n]*)\r?\n\$break\$\r?\n([^\r\n]*)'
    
    # Replace pattern: keep the text before and after $break$, join them directly
    $newContent = $content -replace $pattern, '$1$2'
    
    # Write the modified content back to the file
    $newContent | Set-Content -Path $FilePath -NoNewline
    
    Write-Host "File processed successfully: $FilePath" -ForegroundColor Green
}
catch {
    Write-Error "Error processing file: $($_.Exception.Message)"
    exit 1
}
